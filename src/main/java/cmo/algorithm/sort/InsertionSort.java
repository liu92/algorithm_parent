package cmo.algorithm.sort;

import java.util.Arrays;

/**
 * ClassName: insertionSort
 * Description: 插入排序
 * 往有序的数组中快速插入一个新的元素。它的算法思想是：把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素),
 * 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的.
 * 插入排序由于操作不尽相同, 可分为 直接插入排序 , 折半插入排序(又称二分插入排序), 链表插入排序 , 希尔排序 。我们先来看下直接插入排序。
 *
 * 直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。
 * Author:   lin
 * Date:     2019/3/10 22:40
 * History:
 * <version> 1.0
 */
public class InsertionSort {

    public static void main(String[] args) {
//        int [] counarr ={3,34,24,26,75,54,96,64,1};
        int  [] counarr={34, 8, 64, 51, 32, 21};
        System.out.println("未排序数组顺序为："+Arrays.toString(counarr));
        insertSort(counarr);
        System.out.println("经过插入排序后的数组顺序为:  " + Arrays.toString(counarr));
    }

    /**
     * 功能描述: 插入排序
     *
     * 1. 从第一个元素开始，该元素可以认为已经被排序
     * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
     * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
     * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
     * 5. 将新元素插入到该位置后
     * 6. 重复步骤2~5
     * @param arr  待排序数组
     * @return:
     * @since: 1.0.0
     * @Author:lin
     * @Date: 2019/3/11 19:55
     */

    public static void insertSort(int[] arr){
        /**
         * 这里 i =1 ,表示 从第一个元素开始，该元素可以认为已经被排序了。所以 不考虑i=0
         */
        for (int i=1; i<arr.length;i++){
            //取出一个元素
            int tmp=arr[i];
            /**
             *插入排序基本思想 ： 将数组中所有元素和前面已经排好序（也就认为 第一元素已经排好了序）的元素做比较，
             * 如果j>0 并且 数组中的  第一个元素 大于 第二个元素 那么就将 第一个元素 放在第二个元素的位置。
             * 如果第一个元素 不大于 第二个元素，那么就 将 取出的元素 赋值给 arr[j]。 为啥要 赋值给arr[j] 呢？
             * 比如在j=0 和tmp =2 时，数组的第一个元素是arr[0] = 3 和 数组的arr[2] =24 ,那么数组下标为0元素的位置 不大于 数组下标为2的元素。 所以将
             * 数组下标为2的元素 赋值给数组 下标为1 的位置。因为 arr[j-1]取出来的元素在tmp取出元素前面。而后将这个元素放到arr[j-1]的后面一位。
             * 就是将数组中位置进行替换。
             *
             * 比如第一次循环 i=1：tmp=arr[i] , 那么 j=1 , arr[1-1]=arr[0] 和 tmp 比较。如果arr[0] 大于tmp 并且 j>0; 那么就将arr[0] 位置的元素和arr[1] 的
             * 元素位置互换。
             *
             * 如果 arr[0] 不大于 tmp 那么就进入 else判断， 将tmp的位置的元素赋值给arr[1]的位置 并退出循环。
             *
             * 当进行第二次循环的时 i=2，tmp=arr[2] , j=2, 那么内层循环就是3次，进入if判断。如果 arr[2]>tmp ，那么就将arr[j-1]的位置元素放在arr[j]的
             * 位置。 进入内层下一次循环 ，arr[1-1]=arr[0] 和tmp 比较，可以知道arr[0] 的元素不大于tmp 的元素，所以进入 else判断
             * arr[j]=arr[1]  所以将tmp=arr[2] 赋值给arr[1] 的下标位置。
             *
             */
            for (int j=i;j>=0;j--){
                // 比如 i=1 ,那么这里就arr[0], 通过arr[0]来和arr[1]比较，依次类推
                 if(j>0 && arr[j-1]>tmp){
                     // 如果该元素（已排序）大于取出的元素temp，将该元素移到下一位置,
                   arr[j]=arr[j-1];
                 }else{
                     /**
                      * 如果不大于， 说明arr[j-1]取出来的元素在tmp取出元素前面。然后将这个元素放到arr[j-1]的后面一位，意思就是
                      * 在进入下一次循环时，如果j=2, arr[j-1]>tmp 不进入该判断，那么j=1 是 如果arr[0] 不大于tmp 那么就进入了else 判断。
                      * 这时将 tmp=arr[2] 的下标对于的元素赋值给 arr[1]。
                      */
                     arr[j] = tmp;
                     break;
                 }
            }
            System.out.println("第"+i+"次排序后的结果为："+ Arrays.toString(arr));
        }
    }
    // 由于直接插入排序每次只移动一个元素的位， 并不会改变值相同的元素之间的排序， 因此它是一种稳定排序。
    /**
      这里总结一下：就是在进行数据排序时候
     */

    /** 打印结果
     *
     Sorting:  [3, 34, 24, 26, 75, 54, 96, 64, 1]
     Temping:  [3, 34, 34, 26, 75, 54, 96, 64, 1]
     Sorting:  [3, 24, 34, 26, 75, 54, 96, 64, 1]
     Temping:  [3, 24, 34, 34, 75, 54, 96, 64, 1]
     Sorting:  [3, 24, 26, 34, 75, 54, 96, 64, 1]
     Sorting:  [3, 24, 26, 34, 75, 54, 96, 64, 1]
     Temping:  [3, 24, 26, 34, 75, 75, 96, 64, 1]
     Sorting:  [3, 24, 26, 34, 54, 75, 96, 64, 1]
     Sorting:  [3, 24, 26, 34, 54, 75, 96, 64, 1]
     Temping:  [3, 24, 26, 34, 54, 75, 96, 96, 1]
     Temping:  [3, 24, 26, 34, 54, 75, 75, 96, 1]
     Sorting:  [3, 24, 26, 34, 54, 64, 75, 96, 1]
     Temping:  [3, 24, 26, 34, 54, 64, 75, 96, 96]
     Temping:  [3, 24, 26, 34, 54, 64, 75, 75, 96]
     Temping:  [3, 24, 26, 34, 54, 64, 64, 75, 96]
     Temping:  [3, 24, 26, 34, 54, 54, 64, 75, 96]
     Temping:  [3, 24, 26, 34, 34, 54, 64, 75, 96]
     Temping:  [3, 24, 26, 26, 34, 54, 64, 75, 96]
     Temping:  [3, 24, 24, 26, 34, 54, 64, 75, 96]
     Temping:  [3, 3, 24, 26, 34, 54, 64, 75, 96]
     Sorting:  [1, 3, 24, 26, 34, 54, 64, 75, 96]
     end:  [1, 3, 24, 26, 34, 54, 64, 75, 96]
     */



}
